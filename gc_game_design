Часть I. Вводная.

Привет, Кит! Я придумал игру про гномов, давай сделаем её прототип вместе с тобой в Unity (версия 2023.1.13f1) - я опишу тебе геймдизайн, а ты поможешь мне с написанием кода, т.к. я не программист и твоя помощь будет бесценной.
Геймдизайн следующий, вот основной концепт:
Игра состоит из уровней, в которых отряд из 3-5 гномов (воин, лучник и лекарь) бегут слева-направо. Т.е. в своей базе это раннер. Задача чтобы отряд достиг конца маршрута в крайней правой части уровня.
Игрок не управляет отрядом, отряд гномов бежит сам. Препятствий нет.
На пути отряда через промежутки встречаются паки монстров, с которыми отряд сражается сам, без контроля со стороны игрока: воин таунтит на себя 1-2 монстров, лучник стреляет, лекарь лечит. 
Если бой окончился победой (т.е. монстры убиты и хотя бы один гном жив) - игра предлагает выбрать игроку из 3-х гномов на выбор, которые дополнят отряд и отряд бежит дальше. Если бой окончился поражением - увы, надо начинать уровень сначала.
Пройдя таким образом 5-10 сражений, игрок значительно увеличивает отряд и вот уже у него бежит целая армия, чтобы сразиться с финальным боссом.
Главная задача и главный интерес игрока - составить в процессе забега сбалансированный отряд гномов, который может и выдержать достаточно урона, и подлечиться и нанести достаточно урона, чтобы победить финального босса.
У этой игры большой потенциал в строении билдов. При этом сам процесс геймплея очень простой - это раннер + автобатлер + сборка колоды (отряда). По сути игроку нужно только выбирать, кого взять в отряд. В дальнейшем геймплей можно расширить, добавив артефакты, которые можно выбирать у продавца, который встречается между паками. Также можно будет сделать, что первых 3-5 гномов игрок будет выбирать самостоятельно перед началом уровня.
Самое интересное - в дальнейшем эту игру можно сделать с PvP - разделив экран горизонтально - два отряда гномов будут бежать через паки монстров навстречу друг-другу и игроки будут составлять отряд (колоду), видеть, как другой игрок составляет отряд (колоду) на другой половинке экрана. В финале оба игрока сходятся в автобое друг против друга и победит тот, кто грамотнее собирал отряд и/или подглядывал как это делает противник на другой стороне экрана (т.е. бои и выбор карт (бойца в отряд) у обоих игроков будут параллельно, например на выбор будет даваться 10 секунд и отряды дальше бегут через паки монстров навстречу друг другу.
В общем это потенциально может быть хитовой игрой. Как одиночной для стима, так и мультиплеерной для телефонов - она простая и залипательная, ведь мы нарисуем толпу смешных гномов с анимациями и это  будет весело смотреть и интересно набирать отряд. Пока техническое название этой игры “Gnomes! Charge!”

Часть II. Как лучше начать разработку

А теперь к разработке. У нас нет программиста. Я - геймдизайнер, а моя супруга Катерина - художница. Чтобы мы могли начать, нам нужно сделать прототип, и я надеюсь ты, Кит, сумеешь нам помочь.

У нас есть выбор:
1. Либо мы начнем с тобой писать код с чистого листа, тогда все решения по коду будут на твоей стороне. 
2. Либо я могу взять ассет для игры-раннера от More Mountains https://infinite-runner-engine-docs.moremountains.com/index.html это упростит старт работ, но тебе надо знать все детали этого ассета. 
3. Либо я могу взять ассет top-down игры также от More Mountains: https://topdown-engine-docs.moremountains.com/ - здесь нет раннер-механики, но зато есть много готовых решений по персонажам, атакам и Ai, но тебе также придется разбираться с решениями этого ассета, чтобы интегрировать наши решения.

Как ты считаешь, какое решение лучше? Пока не начинаем кодить, просто рассуждаем. 

Часть III. Как я представляю прототип, т.е. наш minimal value product (MVP)

Часть IV. План и этапы работы
Этап 1. Создаем главное меню
Делаем экран запуска уровня с кнопкой Start и кнопкой Quit для выхода из игры. Т.е. делаем сцену с двумя кнопками и скриптом MainMenu, в нем два serialized field - в одно поле serialized field помещаем кнопку, которая стартует уровень (т.е. сцену уровня), в другую - кнопку которая выходит из игры.

Этап 2. Создаем заготовку уровня
Делаем один уровень во всей игре (сцену) с боссом в конце.
Это сцена с видом сверху-сбоку (top-down вид, т.е. мы в ортографическом виде видим землю и часть дальнего плана как фон (лучший пример - посмотри скриншоты игры Castle Crashers). Графику я сделаю сам.
Сцену можно запускать в Unity отдельно от Main Menu. 
В этой сцене есть объект LevelController, в который мы положим скрипт LevelController. 
LevelController определяет условия игры: 1) проигрыш, если все гномы игрока убиты - тогда игра включает попап с надписью Game Over (это просто объект-окно, в нем есть кнопка Restart (начинает уровень с начала) и Exit to Main Menu - выходит в главное меню); -  2) победу, если убит финальный босс. В этом случае выводим VictoryScreen, в этом окне кнопки Again! и Exit to Main Menu (первая начинает уровень снова, а вторая кнопка выходит в главное меню).
Сцена представляет собой длинную дорогу, мы видишь лишь часть с нашим отрядом. Камера закреплена на нашем отряде так, что отряд немного левее центра экрана, чтобы когда отряд достиг монстров, сражение проходило по центру. Если для этого нужно что-либо кодить - также делаем это в скрипте LevelController
Когда отряд достигает пака монстров - отряд останавливается, т.е. раннер прекращается и начинается бой. Для этого нам надо сделать небольшую паузу в 1 секунду между бегом и боем, а затем начинается бой - гномы замедляются затем останавливаются, затем гномы и враги выбирают цели и атакуют.
Паки монстров и финального босса в прототипе мы расставляем вручную, чтобы избежать дополнительного кодинга.
В LevelController’е есть блок GnomesStartList - это расширяемый список, в нем может быть сколько угодно пунктов - это гномы с которыми игрок стартует уровень. Можно указывать количество. Эти гномы будут помещены в squad_box отряда (о нем - в последующих пункта). Например:
> gnome_warrior х10
> gnome_archer x5
> gnome_healer х2

В LevelController’е есть блок GnomesDropList - это расширяемый список, в него вставляем будущие префабы гномов и их количество, которых мы сможем выбирать после боев (после каждого боя, если он победный игра автоматически ставится на паузу и игроку предлагается N раз выбрать дополнительных гномов в свой отряд) и шанс выпадения этого “оффера”. Выглядит например так:
> gnome_warrior | amount: 1 | drop chance: 0.75
> gnome_archer | amount: 1 | drop chance: 0.75
> gnome_healer | amount: 1 | drop chance: 0.75
> gnome_warrior | amount: 2 | drop chance: 0.25
> gnome_archer | amount: 2 | drop chance: 0.25
> gnome_healer | amount: 2 | drop chance: 0.25
> gnome_warrior | amount: 3 | drop chance: 0.1
> gnome_archer | amount: 3 | drop chance: 0.1
> gnome_healer | amount: 3 | drop chance: 0.1
Выпадает после каждого боя только 3 “оффера” рандомно из этого списка. 

Этап 3. Создаем префабы персонажей
Создаем префабы гномов и врагов. Гномы - треугольнички (у них же колпачки) цвет определяет класс, враги - кружочки, цвет определяет тип врага. Стрелы лучников - маленькие полосочки. Т.е. супер-минималистичная графика для старта, чтобы не усложнять процесс. Вводим 3 типа гномов: воин, лучник, лекарь (делаем три префаба: gnome_warrior, gnome_archer, gnome_healer). И три вида врагов - волк (префаб enemy_wolf) (быстро атакует вблизи), оса (префаб enemy_wasp) (атакует издалека) и огр (префаб enemy_ogre) (атакует вблизи, медленно, но наносит урон по области, будет боссом). Гномы с визуалом-треугольниками, монстры с визуалом-кружочками. Каждому префабу будет добавлен скрипт CharacterEntity с датой-данными.

Этап 4. Создаем Дату персонажей
Создаем скрипт CharacterEntity, который добавим в префаб каждого гнома и каждого монстра - он позволит задать базовые значения каждого персонажа. Показатели будут следующие:

ID - это уникальный ID каждого монстра, вводим вручную, например gnome_warrior. Или enemy_wolf
Is gnome - отмечаем галочкой, тогда игра знает, что это тип этого персонажа - гном. Другие гномы его не атакуют. Но атакуют враги. Гном-лекарь лечит только гномов или себя, т.е. своего типа.
Is enemy - отмечаем галочкой (нельзя одновременно отметить is gnome и is enemy) - тогда игра знает, что тип этого персонаж - монстр. Другие монстры его не атакуют, но гномы - атакуют. Монстр-лекарь лечит только других монстров или себя, т.е. своего типа.
HP - здоровье этого персонажа
Armor - броня персонажа. Каждый входящий урон по этому персонажу снижается на это значение брони.
AttackSearchTargetRadius - в этом радиусе этот персонаж в бою ищет цели, которые он будет атаковать
Melee Damage  - урон в ближнем бою. Все персонажи по умолчанию могут драться в ближнем бою. Но если отмечено,что персонаж дальнего боя или лекарь, то преимущество имеют дальний бой или лечение. Только если лучника или лекаря атакуют в ближнем бою - они будут в ответ производить атаку ближнего боя
Melee Damage Duration - сколько в секундах персонаж производит (“заряжает”) атаку (замахивается мечом, например), т.е. через это время персонаж нанесет урон после инициации атаки.
Melee Damage Cooldown - через сколько секунд персонаж атакует после первой атаки. Чем меньше это значение, тем чаще атакует персонаж (т.е. фактически это скорость атаки)
Melee Damage Distance - с какого расстояния персонаж останавливается и начинает осуществлять атаку ближнего боя. Например персонажи с копьями могут начать атаковать врага раньше.
Melee Hit Chance - при каждой атаке ближнего идет проверка - удалось попасть или нет. Это значение определяет значение шанса промаха или попадания. Чем это значение выше, тем больше шансов, что атака попадет по цели и цель получит урон.Чем ниже - тем больше шанс что персонаж промажет атакой ближнего боя и цель не получит урон. Например, Melee Hit Chance равен 0.8 - это значит с 80% вероятностью каждая атака персонажа попадет и лишь 20% шанс что промажет. 
Is Ranged - галочка. Если отмечена - персонаж становится лучником и атакует издали. Если монстр атакует этого персонажа в ближнем бою, то лучник не будет перестает применять дальнобойные атаки (Ranged Damage, Ranged Damage Duration, Ranged Damage Cooldown Ranged Damage Distance), а начнет атаковать в ближнем бою, используя значения Melee Damage, Melee Damage Duration, Melee Cooldown, Melee Damage Distance.
Ranged Damage - если is Ranged отмечено - указываем урон каждой дальнобойной атаки
Ranged Damage Duration -  - сколько в секундах персонаж производит (“заряжает”) атаку (натягивает тетиву лука, например), т.е. через это время персонаж нанесет дальнобойный урон после инициации атаки.
Ranged Damage Cooldown - через сколько секунд персонаж атакует после первой дальнобойной атаки. Чем меньше это значение, тем чаще атакует персонаж (т.е. фактически это скорость дальнобойной атаки)
Ranged Damage Distance - если Is Ranged отмечено - указываем с какого расстояния атакует персонаж
Ranged Hit Chance - шанс попадания или промаха атакой дальнего боя. По аналогии с шансом попадания ближнего боя.
Is Healer - если отмечено, то этот персонаж - лекарь и лечит себя или персонажей своего типа. В первую очередь тех, у кого меньше здоровья в %. Если персонаж-лекарь “заперт” в ближнем бою, то он использует свои показатели Melee Damage, Melee Damage Duration, Melee Cooldown, Melee Damage Distance чтобы наносить урон противнику в ближнем бою. Однако, если кулдаун лечения проходит, он время-от-времени лечит себя или союзника с меньшим % здоровья. Т.е. он атакует в ближнем бою и лечится попеременно, в зависимости у какой из спобностей (ближнего боя или лечения) первым законится кулдаун. Если у персонажа одновременно с Is Healer отмечено Is Ranged - то он будет чередовать Ranged и Healing действия, в зависимости от того, какой из кулдаунов окончился раньше. 
ВАЖНОЕ ПРАВИЛО! Если у персонажа отмечены и лечение и дальнобойная атака, то он выполняет их по приоритетам от важного к менее важному: лечение -> дальнобойная атака. Если отмечены все три действия, то приоритеты такие же: лечение -> дальнобойная атака->ближний бой. Однако если у персонажа отмечено лечение и/или дальний бой, он не будет сам приближаться к цели, чтобы перейти в ближний бой, а будет производить эти действия издалека. 
Healing Power - сколько здоровья восстанавливает один каст лечения
Healing Range - радиус, в пределах которого персонаж лечит союзников.
Healing Target Search Range - радиус в пределах которого персонаж может увидеть цели, чтобы затем подбежать ближе, чтобы они вошли в Healing Range и начать их лечить.
Healing Duration - сколько происходит каст лечения, прежде чем произойдет восстановление здоровья выбранной лекарем цели.
Healing Cooldown - через сколько персонаж сможет лечить вновь.
Speed in Battle - скорость перемещения персонажа в бою. Тут важный ньюанс - вне боя гномы бегут слева-направо кучкой, отрядом с одинаковой скоростью. А паки монстров вообще стоят на маршруте забега неподвижно. И только в бою, когда персонажи будут перемещаться к целям - будет использоваться параметр скорости, т.е. с какой скоростью персонаж перемещается к цели в бою, чтобы достичь
Ability List - список способностей, которые может использовать персонаж. Это расширяемый список - можем указывать сколько полей нам нужно прямо в нем. В поля вкладываем дата-файлы (ассеты) или скрипты способностей. Все необходимое для применения способностей будет уже в самих способностях. Сразу заготовим и сделаем две способности Taunt и Mass Heall. Taunt - будет применять гном-воин, он применяет автоматом если в радиусе есть монстры (CheckRadius), это крик, который провоцирует монстров в радиусе действия (TauntRadius) бежать к воину и атаковать только его в течение 5 секунд (TauntDuration), дальше монстр вновь переходит к выбору цели. У Таунта есть кулдаун (TauntCooldown), воин использует его по кулдауну. Mass-Heal будет применять лекарь - у способности есть радиус (MassHealRadius) и сила лечения (MassHealPower), а также кулдаун MassHealCooldown. 
CanCryForHelp - способность кричать о помощи, чтобы пришла подмога, если персонажа атакуют в ближнем бою. Может быть True или False (галочка)
CryForHelpHPPercentage - от какого уровня здоровья в % начинает кричать о помощи - указываем проценты в формате 0.N (Например 0.2 - это значит что будет кричать когда изней 20% или меньше)
CryForHelpRadius - радиус крика о помощи, в пределах которого его могут слышать другие гномы
CryForHelpPower - два числа от 0.1 и до 1 - сила крика о помощи. Варьируется увеличением первой характеристики и уменьшением второй. Например сила крика от 0.8 до 1 - сильный крик, а от 0.1 до 0.15 - слабый. Это значение сравнивается со значением ReadyForHelp у других персонажей
ReadyForHelp - если сила CryForHelpPower выше или равна значению RadyForHelp - то персонаж меняет свою цель на цель, атакующую персонажа, зовущего на помощь и бежит/атакует в сторону персонажа, атакующего зовущего на помощь.
Character Ai Brains - это пустой слот (поле), куда нам надо вложить код или behaviour-tree типа поведения персонажа. Это будут отдельные дата-файлы с образами действия гномов и монстров. О них - в следующем пункте.

Этап 5. Создаем “мозги” персонажей
Создаем несколько ассетов (или скриптов) “мозгов”, которые определяют поведение гномов и врагов - эти ассеты мы будем вкладывать в Character Ai Brains поле в каждом из префабов персонажей.

Мозги гномов:

GnomeBrains_Warrior - это мозги гномов, определяющие их поведение:
При начале боя использует AttackSearchTargetRadius и отмечает для себя врага как цель и бежит атаковать её. Цель для атаки не меняется в процессе сокращения расстояния между ней и гномом-воином.
Если в радиусе TauntRadius есть враги - гном-воин использует Taunt, провоцируя врагов атаковать его. Если такой способности нет - то персонаж её не применяет.
Если враг, с которым сражается воин убит - воин ищет ближайшего врага и бежит атаковать его.
Отрабатывает HearingRadius, слушая зовы о помощи, и если они (зовы о помощи) равны или превышают его ReadyForHelp - он переключается со своей цели и бежит атаковать цель, которая атакует зовущего на помощь.
Умирает, когда здоровье становится 0 - графика персонажа становится черной (красим в черный спрайт монстра), персонаж перестает перемещаться, атаковать и вообще что-либо делать, так остается 2 секунды, затем он сплющивается по Y с пивотом в своей нижней части (в 0 по Y), т.е. почернел и сплющился и удаляется из игры. Монстры которые атаковали или лечили его обновляют свои цели, а не продолжают атаковать труп. 

GnomeBrains_Healer - это мозги гнома-лекаря, определяющие его поведения
В начале боя отбегает назад почти на самое далекое расстояние от гномов-воинов, чтобы лечить издалека
Раз в 2 секунды используя Healing Target Search Range может принять решение приблизиться к цели лечения, если радиус лечения не достает до цели
Зовет о помощи (это действие не прерывает прочих действий, а работает параллельно), если здоровье падает ниже указанного в CryForHelpHPPercentage
Атакует в ближнем бою монстра, если тот напал на него в ближнем бою и попеременно лечится или лечит союзников (приоритет у лечения, если атака на кулдауну. Если лечение на кулдауне а атака нет - атакует).
Если монстр перестал его атаковать и переключился на воина или другого персонажа - постарается отбежать на среднее расстояние, и продолжит лечить цели издалека.
Лечит цель, которая зовет на помощь, если параметр ReadyForHelp лекаря равен или превышает силу выкрика о помощи зовущего (CryForHelpPower)
Умирает, когда здоровье становится 0 - графика персонажа становится черной (красим в черный спрайт монстра), персонаж перестает перемещаться, атаковать и вообще что-либо делать, так остается 2 секунды, затем он сплющивается по Y с пивотом в своей нижней части (в 0 по Y), т.е. почернел и сплющился и удаляется из игры. Монстры которые атаковали или лечили его обновляют свои цели, а не продолжают атаковать труп. 

GnomeBrains_Archer - это мозги гнома-лучника, определяющие его поведение
В начале боя выбирает случайную цель и начинает атаковать её издалека
Если цель перемещается и выходит из радиуса атаки - он с шансом 50% побежит, чтобы вновь оказаться в радиусе, позволяющем атаковать эту цель, либо если если есть другие цели - то с шансом 50% он переключится на другую цель. Если цель только одна - он будет перебегать за ней, чтобы оставаться в радиусе досягаемости дальнобойной атакой.
Атакует в ближнем бою монстра, если тот напал на него в ближнем бою.
Если монстр перестал его атаковать и переключился на воина или другого персонажа - постарается отбежать на среднее расстояние, и продолжит атаковать цели издалека. 
Зовет о помощи (это действие не прерывает прочих действий, а работает параллельно), если здоровье падает ниже указанного в CryForHelpHPPercentage
Может менять цель и атаковать противника союзника, который зовет на помощь, если параметр ReadyForHelp лучника равен или превышает силу выкрика о помощи зовущего (CryForHelpPower). Если такой цели нет, даже если зовущий кричит о помощи - тогда лучник продолжает атаковать свою цель.
Умирает, когда здоровье становится 0 - графика персонажа становится черной (красим в черный спрайт монстра), персонаж перестает перемещаться, атаковать и вообще что-либо делать, так остается 2 секунды, затем он сплющивается по Y с пивотом в своей нижней части (в 0 по Y), т.е. почернел и сплющился и удаляется из игры. Монстры которые атаковали или лечили его обновляют свои цели, а не продолжают атаковать труп. 

Мозги гномов возможно стоит объединить и сделать один файл-мозг общего поведения GnomeBrains, который будет объединять схожие действия и разделять частные. Скорее всего единый мозг будет хоть и больше, но удобнее для правок.

Мозги монстров:

MonsterBrain_Wold - идентичны мозгам воина, но у волка нет Taunt’а и он приходит на помощь только своим монстрам-союзникам.

MonsterBrain_Wasp - идентичны мозгам стрелка

MonsterBrain_Ogre - идентичны мозгам воина, но имеет особую атаку Slam, которую производит редко (раз на три атаки), но она наносит урон по площади и откидывает гномов в этом радиусе на некоторое расстояние (им придется подбегать вновь). Напомню, монстры активируют способности, если они вложены в их дату (CharacterEntity). Если это строка пуста - код это обрабатывает и персонаж не производит использование способности (т.е. игра не упадет, не багнет)

Мозги монстров также можно объединить в один файл, обрабатывающий все варианты, а разделять их поведение уже настройками и способностями в личной дате каждого в CharacterEntity.

Кладем мозги в field (слот, поле) Character Ai Brains в CharacterEntity в префабе каждого персонажа и вуаля - у нас заготовлены персонажи для будущего уровня.

Этап 6. Создаем “бокс отряда” - squad box

Гномы бегут отрядом и достигая паков врагов сражаются тоже с “отрядами врагов”. Нам надо сделать такую сущность как squad box. Это может быть префаб. 

В этом префабе есть несколько объектов с вложенными позициями персонажей отряда - это “построения”. Например игрок в дальнейшем сможет переключать строй с клина на квадрат или разрозненный строй. Соответственно в инспектора у объекта squad-box можно задать количество построений (формаций) и перенесети соответствующий объект содержащий в себе все позиции персонажей в этот список формаций. Количество формаций задается нами из может быть сколько придумаем.

В каждой формации есть список позиций внутри неё. Т.е. создали формацию в списке, разворачиваем её и добавляем в неё позиции - переносим объекты позиций этой формации в список. В корневом объекте squad box должен быть расширяемый список, в который мы переносим все объекты (трансформы) позиций для персонажей. У каждой позиции есть настройка priority queue - это очередность, в которой заполняются позиции: например у первых 10 слотов в центре squad box priority queue равно 1. У следующих 10 слотов, дальше от центра - 2 и т.д.: сначала заполняются все слоты первых приоритетов, затем заполняются следующие, это позволит заполнять отряд от центра к краям. Также для каждой позиции есть три настройки “веса” - какой тип юнита туда вероятнее попадет при добавлении (когда игрок будет выбирать гнома) - чтобы воины чаще попадали на передние позиции, а лекари и стрелки - на задние: 
Выглядит этот список так:

position 1 - заголовок позиции 
object transform - поле в которое перенесли объект позицим из инспектора
priority queue: 2 - здесь мы видим, что позиция уже для большего отряда, когда позиции приоритета 1 уже будут заполнены.
melee 0.1 | ranged 0.6 | healer 0.6 - это веса (от 0 до 1, по сути проценты, где 0.1 - 10%, 1 - 100%). 
По этому примеру видно, что эту позицию при добавлении в отряд скорее займет персонаж дальнего боя. Персонаж дальнего боя определяется наличием Is Ranged. А персонаж-лекарь определяется наличием Is Healer. Напомню все персонажи имеют Melee Damage. Т.е. если персонаж не имеет Is Ranged и Is Healer - он воин ближнего боя. Если имеет только Is Ranged (помимо Melee Damage) - дальнего. Если имеет Is Healer (помимо Melee) - он лекарь. Аа если имеет и Is Ranged и Is Healer - он считается лекарем и будет проверяться по весам для помещения в отряд как лекарь. Такая же система у монстров.

Следующая важная настройка squad box’а - это AggroRadius. Это радиус от центра объекта squad box. Aggro Radius есть и у отряда игрока и у паков (отрядов монстров). Когда отряд гномов добегает до пака монстров именно коллизия AggroRadius’ов инициирует начало боя: отряд гномов тормозит с небольшой инерцией (это величину тоже можно вынести в настройку squad box и назвать EasingToStop - отряд как бы мультяшно тормозит в клубах пыли и проезжает слегка вперед).

Когда бой закончен, выжившие гномы вновь занимают свои позиции и бегут к следующему паку врагов. 

Важно отметить, что когда начинается бой - гномы сходят со своих позиций в squad box согласно своему поведению - кто-то отходит назад (лекари и стрелки), воины бегут к монстрам, чтобы “танковать” их. построение скорее определяет сколько персонажам придется пробежать с начала боя, сколько драгоценного времени они потеряют, прежде чем начнуть стрелять, лечить или танковать. 

У монстров также есть squad box с теми же принципами.

Итого, у нас есть персонажи, гномы и монстры. Персонаж определяется своим префабом, а его данные - введенными значениями в прикрепленном к префабу CharacterEntity.
Персонажи объединены в squad-box’ы. Squad box’ы определяют формации отряда (построение), позиции внутри формаций. Позиции внутри формаций имеют очередность заполнения и веса приоритетов для типов добавляемых гномов (и врагов, т.к. squad-box’ы это и паки врагов). У squad box’а есть аггро-радиус, которые при коллизии с другим squad-box’ом запускает easing-торможение отряда, после чего начинается бой, в которой персонажи действуют согласно своим Ai “мозгам”

Итак, персонажи есть, отряды есть, паки монстров есть.


Этап 7. Предсоздание паков (squad-box’ов) гномов и монстров

Создаем squad-box для отряда гномов. Он изначально пустой, т.к. он заполнится на старте гномами из списка в GnomesStartList в LevelController’е
Создаем squad-box’ы монстров. В них на позиции мы сразу добавляем префабы монстров: волков, ос, огров.
Размещаем по уровню стартовый squad-box отряда гномов
Создаем камеру в уровне и прикрепляем к отряду гномов
Размещаем по уровню squad-box’ы врагов и последий squad-box босса


Этап 8. Создаем флоу уровня
Создаем базовый флоу (течение) уровня. Он может быть прописан как в одном скрипте и прикреплен к уровню, так и рассредоточен на несколько скриптов, чтобы не держать один большой.

Вот само флоу (течение) уровня:

Начало. Группа из стартовых гномов, указанных в пункте GnomesStartList в LevelController’е стоит в левой части экрана в течение 1-2 секунд (эту паузу, стояние можно вынести в LevelController и назвать PauseBeforeGnomesStartRun, а затем начинает бежать.

Бег. Группа гномов двигается влево. Визуально отряд остается на месте, а продвигается фон, ведь камера закреплена на отряде, но по факту отряд перемещается по уровню слева-направо. Уровень простой - это “корридор” слева-направо. Группа постоянно ускоряется, чтобы ощущалась что они бегут быстрее и быстрее. Т.е. должно быть так - гномы медленно стартуют и разгоняются-разгоняются, потом уже несутся - и БУМ - влетают в первый пак монстров.

Инициация боя. Группа гномов имеет свой squad_box - это объект, в который помещается весь отряд. Squad_box имеет позиции для всех гномов и вероятно прочие настройки, но нас сейчас интересует его AggroRadius. Паки монстров также имеют свой squad_box и свой aggro_radius. Когда aggro_radius’ы отряда гномов и отряда монстров коллизятся, то инициируется бой следующим образом: отряд гномов тормозит, чуть-чуть проезжая ближе к монстрам (но не вплотную, как бы “скользят” или мультяшно тормозят с инерцией, эту настройку мы вынесем в squad_box у отряда гномов). В момент инициации боя монстры и гномы НЕ начинают атаковать друг друга. Когда гномы затормозили, появляется большая надпись поверх всего CHARGE!. Только после этого начинается фаза боя и гномы и монстры бегут в атаку, используя свои мозги.

Бой. Проходит автоматически, до момента пока одна из сторон победит. Бой должен выглядеть живо - гномы бегают друг-другу на помощь, воины таунтят монстров и спасают лекарей, лучники не всегда стреляют в верные цели и иногда мажут. Лекари лечат гномов с малым количеством здоровья, а если оказываются атакованными - зовут на помощь. В общем - все как мы выше описали в поведении (в мозгах).

Завершение боя+Награда. 
Если убиты гномы - игра ставится на паузу и показываем попап Поражения.
Если гномы победили - игра ставится на паузу (часть может умереть, но хотя бы остался один) - то показываем попап Награды, в котором показываем три случайных оффера из списка GnomesDropList. Игрок может выбрать только один оффер (нажав по кнопке “Выбрать” под ним), после этого попап пропадает.
В squad_box’е отряда гномов появляются выбранные игроком гномы из оффера, рассредотачиваясь по позициям.
Отряд вновь начинает медленно ускоряясь бежать влево до следующего пака.

Повторение фаз Бег > Инициация Боя > Бой > Завершение Боя+Награда. Ещё несколько повторяющихся этапов Бег-Инициация-Бой-Завершение Боя+Награда. Отряд проходит через 4 таких цикла (количество сражений будем увеличивать по мере роста прототипа) схожим образом. Игрок набирает отряд побольше, благодаря наградам. И отряд бежит к последнему паку, помеченному как “Босс”

Сражение с боссом - такой же бой с инициацией сражения, самим боем, завершением боя и наградой, однако вместо награды - кнопки “Выйти” и “Повторить”.
